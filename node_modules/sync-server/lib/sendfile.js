var fs = require('fs')
  , qs = require('./qs')
  , path = require('path')
  , join = path.join
  , basename = path.basename
  , normalize = path.normalize
  , utils = require('./utils')
  , parse = require('url').parse
  , mime = require('mime');

//todo: seperate errback from httpError from notfound (throws if not isAsset)

exports.mime = mime;

var serve = exports.serve = function(req, res, opts, next) {
  "use strict";

  opts = opts || {};
  if (!opts.path) throw new Error('path required');
  opts.directRequest = true;

  // setup
  var head = ('HEAD' == req.method)
    , get = ('GET' == req.method)
    , root = opts.root ? normalize(opts.root) : null
    , hidden = opts.hidden;

  //handlers
  opts.on404 = opts.on404 || next;
  opts.onError = opts.onError || next;
  if (!opts.httpError) {
    opts.httpError = function(code) {
      next(utils.error(code));
    };
  }

  // ignore non-GET requests
  if (opts.getOnly && !get && !head) {
    return opts.on404();
  }

  // parse url
  var url = parse(opts.path)
    , path = qs.unescape(url.pathname);

  // null byte(s)
  if (~path.indexOf('\0')) {
    return opts.httpError(400);
  }

  // when root is not given, consider .. malicious
  if (!root && ~path.indexOf('..')) {
    return opts.httpError(403);
  }

  // index.html support
  if ('/' == path[path.length - 1]) path += 'index.html';

  // join / normalize from optional root dir
  path = normalize(join(root, path));

  // malicious path
  if (root && 0 != path.indexOf(root)) {
    return opts.httpError(403);
  }

  // "hidden" file
  if (!hidden && '.' == basename(path)[0]) {
    return opts.on404();
  }

  send(req, res, opts);
};


/**
 * Transfer a specified file
 *
 * @param {ServerRequest}
 * @param {ServerResponse}
 * @param {Object} opts
 * @api private
 */

var send = exports.send = function(req, res, opts) {
  "use strict";

  fs.stat(opts.path, function(err, stat) {
    // mime type
    var type = opts.ctype || mime.lookup(opts.path)
      , maxAge = opts.maxAge || 0;

    // ignore ENOENT
    if (err) {
      return ('ENOENT' == err.code || 'ENAMETOOLONG' == err.code) ? opts.on404() : opts.onError(err);
    } else
    if (stat.isDirectory()) {
      return opts.on404();
    }

    // header fields
    if (!res.getHeader('Date')) {
      res.setHeader('Date', new Date().toUTCString());
    }
    //if an asset/public resource was requested
    if (opts.directRequest) {
      if (!res.getHeader('Cache-Control')) {
        res.setHeader('Cache-Control', 'public, max-age=' + (maxAge / 1000));
      }
      if (!res.getHeader('Last-Modified')) {
        res.setHeader('Last-Modified', stat.mtime.toUTCString());
      }
      res.setHeader('Accept-Ranges', 'bytes');
    }
    if (!res.getHeader('Content-Type')) {
      var charset = mime.charsets.lookup(type);
      res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
    }

    // conditional GET support
    if (opts.directRequest && utils.conditionalGET(req)) {
      if (!utils.modified(req, res)) {
        return utils.notModified(res);
      }
    }

    var streamOpts = {}, len = stat.size;

    // we have a Range request
    var ranges = req.headers.range;
    if (opts.directRequest && ranges) {
      ranges = utils.parseRange(len, ranges);

      // valid
      if (ranges) {
        streamOpts.start = ranges[0].start;
        streamOpts.end = ranges[0].end;

        // unsatisfiable range
        if (streamOpts.start > len - 1) {
          res.setHeader('Content-Range', 'bytes */' + stat.size);
          return opts.httpError ? opts.httpError(416) : opts.onError(utils.error(416));
        }

        // limit last-byte-pos to current length
        if (streamOpts.end > len - 1) streamOpts.end= len - 1;

        // Content-Range
        len = streamOpts.end - streamOpts.start + 1;
        res.statusCode = 206;
        res.setHeader('Content-Range', 'bytes ' + streamOpts.start + '-' + streamOpts.end + '/' + stat.size);
      }
    }

    res.setHeader('Content-Length', len);

    // transfer
    if (req.method == 'HEAD') {
      return res.end();
    }

    // stream
    var stream = fs.createReadStream(opts.path, streamOpts);
    req.on('close', stream.destroy.bind(stream));
    stream.pipe(res);

    stream.on('error', function(err) {
      if (res.headerSent) {
        console.error(err.stack);
        req.destroy();
      } else {
        opts.onError(err);
      }
    });
  });
};